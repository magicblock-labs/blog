<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Introducing the Verifiable Randomness Solana Plugin | Magicblock</title>

    <!-- Begin Jekyll SEO tag v2.8.0 -->
<title>Introducing the Verifiable Randomness Solana Plugin | Magicblock</title>
<meta name="generator" content="Jekyll v4.4.1" />
<meta property="og:title" content="Introducing the Verifiable Randomness Solana Plugin" />
<meta name="author" content="Magicblock" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="In blockchain applications, getting truly random numbers is surprisingly difficult. Whether building games, raffles, or fair selection mechanisms, you need randomness that everyone can trust—something traditional coding approaches can’t provide." />
<meta property="og:description" content="In blockchain applications, getting truly random numbers is surprisingly difficult. Whether building games, raffles, or fair selection mechanisms, you need randomness that everyone can trust—something traditional coding approaches can’t provide." />
<link rel="canonical" href="https://blog.magicblock.gg/solana-plugin-vrf/" />
<meta property="og:url" content="https://blog.magicblock.gg/solana-plugin-vrf/" />
<meta property="og:site_name" content="Magicblock" />
<meta property="og:image" content="https://blog.magicblock.gg/assets/images/vrf.png" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2025-04-08T00:00:00+00:00" />
<meta name="twitter:card" content="summary_large_image" />
<meta property="twitter:image" content="https://blog.magicblock.gg/assets/images/vrf.png" />
<meta property="twitter:title" content="Introducing the Verifiable Randomness Solana Plugin" />
<script type="application/ld+json">
{"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Magicblock"},"dateModified":"2025-04-08T00:00:00+00:00","datePublished":"2025-04-08T00:00:00+00:00","description":"In blockchain applications, getting truly random numbers is surprisingly difficult. Whether building games, raffles, or fair selection mechanisms, you need randomness that everyone can trust—something traditional coding approaches can’t provide.","headline":"Introducing the Verifiable Randomness Solana Plugin","image":"https://blog.magicblock.gg/assets/images/vrf.png","mainEntityOfPage":{"@type":"WebPage","@id":"https://blog.magicblock.gg/solana-plugin-vrf/"},"publisher":{"@type":"Organization","logo":{"@type":"ImageObject","url":"https://blog.magicblock.gg/assets/images/magicblock_black.png"},"name":"Magicblock"},"url":"https://blog.magicblock.gg/solana-plugin-vrf/"}</script>
<!-- End Jekyll SEO tag -->


    <link rel="shortcut icon" type="image/x-icon" href="/assets/images/favicon.ico">

    <!-- Font Awesome Icons -->
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous">

    <!-- Google Fonts-->
    <link href="https://fonts.googleapis.com/css?family=Lora:400,400i,700" rel="stylesheet">

    <!-- Bootstrap Modified -->
    <link rel="stylesheet" href="/assets/css/main.css">

    <!-- Theme Stylesheet -->
    <link rel="stylesheet" href="/assets/css/theme.css">

    <!-- Code Stylesheet -->
    <link rel="stylesheet" href="/assets/css/codestyle.css">

    <!-- Jquery on header to make sure everything works, the rest  of the scripts in footer for fast loading -->
    <script
    src="https://code.jquery.com/jquery-3.3.1.min.js"
    integrity="sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8="
    crossorigin="anonymous"></script>

    <!-- This goes before </head> closing tag, Google Analytics can be placed here --> 


</head>

<body class=" dark-mode">

    <!-- Navbar -->
    <nav id="MagicMenu" class="topnav navbar navbar-expand-lg navbar-light bg-white fixed-top">
    <div class="container">
        <!-- <a class="navbar-brand" href="/index.html"><strong>Magicblock</strong></a> -->
        <a class="navbar-brand" href="/index.html">
            <img src="/assets/images/magicblock_black.png" alt="Magicblock" class="mt-1 d-lg-block" style="max-height: 40px;">
        </a>
        <button class="navbar-toggler collapsed" type="button" data-toggle="collapse" data-target="#navbarColor02" aria-controls="navbarColor02" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
        </button>
        <div class="navbar-collapse collapse" id="navbarColor02" style="">
            <ul class="navbar-nav mr-auto d-flex align-items-center">
               <!--  Replace menu links here -->

<li class="nav-item">
<a class="nav-link" href="/index.html">Home</a>
</li>
<li class="nav-item">
<a class="nav-link" href="/categories.html">Categories</a>
</li>

            </ul>
            <ul class="navbar-nav ml-auto d-flex align-items-center">
                <!-- Toggle switch button -->
                <label class="switch">
                    <input type="checkbox" id="themeToggle">
                    <span class="slider round">
                    <i class="fas fa-moon moon-icon"></i>
                    <i class="fas fa-sun sun-icon"></i>
                    </span>
                </label>
                <script src="/assets/js/lunr.js"></script>

<script>
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 1000 );
        $( "body" ).removeClass( "modal-open" );
    });
});
    

var documents = [{
    "id": 0,
    "url": "https://blog.magicblock.gg/404/",
    "title": "",
    "body": " 404 Page not found :(  The requested page could not be found. "
    }, {
    "id": 1,
    "url": "https://blog.magicblock.gg/about.html",
    "title": "About",
    "body": ""
    }, {
    "id": 2,
    "url": "https://blog.magicblock.gg/authors-list.html",
    "title": "Authors",
    "body": "{{page. title}}:     {% for author in site. authors %}                                         {{ author[1]. name }} :       (View Posts)      {{ author[1]. bio }}                          &nbsp;       &nbsp;                                    {% endfor %}  "
    }, {
    "id": 3,
    "url": "https://blog.magicblock.gg/categories.html",
    "title": "Categories",
    "body": "          Categories          {% for category in site. categories %}     {{ category[0] }}:           {% assign pages_list = category[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "
    }, {
    "id": 4,
    "url": "https://blog.magicblock.gg/contact.html",
    "title": "Contact",
    "body": "  Please send your message to {{site. name}}. We will reply as soon as possible!   "
    }, {
    "id": 5,
    "url": "https://blog.magicblock.gg/",
    "title": "Blog",
    "body": "  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          &lt;div class= topfirstimage mt-2  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; background-position: center center; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                            {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                    {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                                    {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                    {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 Read More            	             {% endif %}{% endfor %}  {% endif %}                All Stories:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      "
    }, {
    "id": 6,
    "url": "https://blog.magicblock.gg/privacy-policy.html",
    "title": "Privacy Policy",
    "body": "”{{site. name}}” takes your privacy seriously. To better protect your privacy we provide this privacy policy notice explaining the way your personal information is collected and used. Collection of Routine Information: This website track basic information about their visitors. This information includes, but is not limited to, IP addresses, browser details, timestamps and referring pages. None of this information can personally identify specific visitor to this website. The information is tracked for routine administration and maintenance purposes. Cookies: Where necessary, this website uses cookies to store information about a visitor’s preferences and history in order to better serve the visitor and/or present the visitor with customized content. Advertisement and Other Third Parties: Advertising partners and other third parties may use cookies, scripts and/or web beacons to track visitor activities on this website in order to display advertisements and other useful information. Such tracking is done directly by the third parties through their own servers and is subject to their own privacy policies. This website has no access or control over these cookies, scripts and/or web beacons that may be used by third parties. Learn how to opt out of Google’s cookie usage. Links to Third Party Websites: We have included links on this website for your use and reference. We are not responsible for the privacy policies on these websites. You should be aware that the privacy policies of these websites may differ from our own. Security: The security of your personal information is important to us, but remember that no method of transmission over the Internet, or method of electronic storage, is 100% secure. While we strive to use commercially acceptable means to protect your personal information, we cannot guarantee its absolute security. Changes To This Privacy Policy: This Privacy Policy is effective and will remain in effect except with respect to any changes in its provisions in the future, which will be in effect immediately after being posted on this page. We reserve the right to update or change our Privacy Policy at any time and you should check this Privacy Policy periodically. If we make any material changes to this Privacy Policy, we will notify you either through the email address you have provided us, or by placing a prominent notice on our website. Contact Information: For any questions or concerns regarding the privacy policy, please contact us here. "
    }, {
    "id": 7,
    "url": "https://blog.magicblock.gg/tags.html",
    "title": "Tags",
    "body": "          Tags          {% for tag in site. tags %}     {{ tag[0] }}:           {% assign pages_list = tag[1] %}    {% for post in pages_list %}    {% if post. title != null %}     {% if group == null or group == post. group %}           {% include main-loop-card. html %}     {% endif %}    {% endif %}    {% endfor %}    {% assign pages_list = nil %}    {% assign group = nil %}    {% endfor %}                  {% include sidebar-featured. html %}          "
    }, {
    "id": 8,
    "url": "https://blog.magicblock.gg/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 9,
    "url": "https://blog.magicblock.gg/page2/",
    "title": "Blog",
    "body": "  {% if page. url ==  /  %}            {% assign latest_post = site. posts[0] %}          &lt;div class= topfirstimage mt-2  style= background-image: url({% if latest_post. image contains  ://  %}{{ latest_post. image }}{% else %} {{site. baseurl}}/{{ latest_post. image}}{% endif %}); height: 200px;  background-size: cover;  background-repeat: no-repeat; background-position: center center; &gt;&lt;/div&gt;           {{ latest_post. title }}  :       {{ latest_post. excerpt | strip_html | strip_newlines | truncate: 136 }}               In         {% for category in latest_post. categories %}        {{ category }},         {% endfor %}                                {{ latest_post. date | date: '%b %d, %Y' }}                            {%- assign second_post = site. posts[1] -%}                        {% if second_post. image %}                         &lt;img class= w-100  src= {% if second_post. image contains  ://  %}{{ second_post. image }}{% else %}{{ second_post. image }}{% endif %}  alt= {{ second_post. title }} &gt;                        {% endif %}                                    {{ second_post. title }}          :                       In             {% for category in second_post. categories %}            {{ category }},             {% endfor %}                                                      {{ second_post. date | date: '%b %d, %Y' }}                                    {%- assign third_post = site. posts[2] -%}                        {% if third_post. image %}                         &lt;img class= w-100  src= {% if third_post. image contains  ://  %}{{ third_post. image }}{% else %}{{site. baseurl}}/{{ third_post. image }}{% endif %}  alt= {{ third_post. title }} &gt;                        {% endif %}                                    {{ third_post. title }}          :                       In             {% for category in third_post. categories %}            {{ category }},             {% endfor %}                                                      {{ third_post. date | date: '%b %d, %Y' }}                                    {%- assign fourth_post = site. posts[3] -%}                        {% if fourth_post. image %}                        &lt;img class= w-100  src= {% if fourth_post. image contains  ://  %}{{ fourth_post. image }}{% else %}{{site. baseurl}}/{{ fourth_post. image }}{% endif %}  alt= {{ fourth_post. title }} &gt;                        {% endif %}                                    {{ fourth_post. title }}          :                       In             {% for category in fourth_post. categories %}            {{ category }},             {% endfor %}                                                      {{ fourth_post. date | date: '%b %d, %Y' }}                                  {% for post in site. posts %} {% if post. tags contains  sticky  %}                    {{post. title}}                  {{ post. excerpt | strip_html | strip_newlines | truncate: 136 }}                 Read More            	             {% endif %}{% endfor %}  {% endif %}                All Stories:         {% for post in paginator. posts %}          {% include main-loop-card. html %}        {% endfor %}                   {% if paginator. total_pages &gt; 1 %}              {% if paginator. previous_page %}        &laquo; Prev       {% else %}        &laquo;       {% endif %}       {% for page in (1. . paginator. total_pages) %}        {% if page == paginator. page %}        {{ page }}        {% elsif page == 1 %}        {{ page }}        {% else %}        {{ page }}        {% endif %}       {% endfor %}       {% if paginator. next_page %}        Next &raquo;       {% else %}        &raquo;       {% endif %}            {% endif %}                     {% include sidebar-featured. html %}      "
    }, {
    "id": 10,
    "url": "https://blog.magicblock.gg/quest/",
    "title": "The MagicBlock Quest Is Here: Where the Magic Begins",
    "body": "2025/04/14 - Today, we’re launching the first MagicBlock Quest: a multi-part experience that will begin in the MagicBlock community and evolve onchain, giving you new ways to explore and interact with the MagicBlock world. We built MagicBlock to power real-time experiences that stay entirely within Solana — where your assets, tokens, and actions remain in one place without being split across chains or slowed down by bridges. No interruptions, no fragmentation, no extra steps. A fast, simple way to use the full power of Solana without needing to leave it behind. Whether you are playing a game, placing a trade, or interacting with a smart contract, everything happens in real time, with instant transactions and no lag. You get the speed and responsiveness you expect from everyday apps combined with the transparency, control, and freedom that only decentralized systems can offer. This MagicBlock Quest is your invitation to see that vision in action. You will engage across different spaces, from community channels and creative challenges to live products and partner protocols. Whether you are contributing socially, creatively, or onchain, every step gives you a better sense of what MagicBlock enables and where it is going. What to Expect: Phase 1: Social Sync The first phase is off-chain. You will dive into challenges that immerse you in the MagicBlock world, from sharing insights to decoding lore to engaging with educational content and other community members. These early social quests are more than a starting point. They will also feed into future progression, acting as a booster for later stages of the quest. The more you participate now, the more value your future quests will earn as things evolve. Phase 2: Onchain Unlocks In the second phase, things go onchain. You’ll interact with the world of MagicBlock through real-time transactions, product experiences, and partner integrations — FlashTrade, ZeeBit, and SuperSize among them. These onchain actions help model the future of real-time gaming and finance. The more you engage, the more you unlock. How to Join: We’re opening up the first phase on the 15th of April. To join the quest:  Follow us on [Twitter/Discord/etc].  Watch for the first challenge drop on Galxe.  Participate, share, and signal back. More info and lore will unlock as the community moves through it. "
    }, {
    "id": 11,
    "url": "https://blog.magicblock.gg/dtelecom/",
    "title": "dTelecom x MagicBlock: Powering the Future of Real-Time Decentralized Communication",
    "body": "2025/04/09 - At MagicBlock, we’re building a real-time engine for decentralized applications on Solana. Our cutting-edge ephemeral rollup technology delivers low latency, ultra-cheap fees with dedicated blockspace and, and elastic scalability, all while preserving composability with Solana’s ecosystem. Today, we’re excited to announce our partnership with dTelecom — a perfect use case for our technology that demonstrates its real-world impact. A Perfect Match: Real-Time Performance Meets Decentralized Communication: dTelecom is creating a fully decentralized alternative to services like LiveKit and Agora, where anyone can become a bandwidth provider in a permissionless network. Their platform requires exactly what MagicBlock excels at delivering:  Sub-50ms latency essential for VPN and real-time communication Seamless Solana integration without liquidity fragmentation Ultra-cheap fees thanks to dedicated blockspace and transactions batching Dynamic scaling to handle unpredictable global usage patterns Gas abstraction for frictionless user experiences “We founded dTelecom with a simple but powerful vision: communication infrastructure should be as open, resilient, and accessible as the internet itself,” says Vadim Filimonov, Co-founder at dTelecom. “Finding the right technical partner was crucial to delivering on this promise. MagicBlock’s unique approach to scaling Solana makes them not just a vendor, but a foundational pillar of our infrastructure strategy. ” Why This Partnership Matters: Building real-time, low-latency applications on the blockchain has historically forced difficult trade-offs between performance and decentralization. With MagicBlock’s technology, dTelecom can deliver:  A Web2-level, seamless experience with truly private, censorship-resistant communication.  A sustainable economic model for node operators through instant, on-demand ephemeral rollups Intuitive developer tools that don’t sacrifice user experience “This is a really exciting case where Ephemeral Rollups can help the unit economics of an ambitious network like dTelecom, aside from pure performance,” says Andrea Fortugno, Co-founder at MagicBlock. “Their vision for decentralized communication aligns perfectly with our capabilities, and we’re proud to provide the technology that helps make their ambitious roadmap possible. ” Reimagining Communications Infrastructure: dTelecom’s vision goes beyond just another communication tool — they’re building the foundation for truly censorship-resistant, private internet access through a comprehensive suite of tools including dVPN and real-time communication SDKs. For their diverse ecosystem of bandwidth providers, privacy-conscious users, and developers, MagicBlock provides the invisible but essential infrastructure layer that ensures their platform can compete with centralized alternatives on performance while maintaining all the benefits of decentralization.  “We evaluated numerous scaling solutions, but only MagicBlock offered what we truly needed—real performance without sacrificing the principles that matter to us,” continues Filimonov. “Their technology isn’t just complementary to our vision; it’s essential to delivering what we’ve promised our users and developers. ” What’s Next: As dTelecom expands its SDKs, node operator program, and enterprise integrations, MagicBlock will scale alongside them—providing the performance foundation that makes true decentralized communication possible. This partnership opens a new chapter for both teams and the wider Solana ecosystem, demonstrating that with the right infrastructure, decentralized applications can truly compete with—and exceed—their centralized counterparts. Real-time. Reliable. Unstoppable. This is the future of communication we’re building together. Follow dTelecom at https://x. com/DTEL_org Unleash the Power of MagicBlock. Explore our documentation, or follow us on X and Discord to stay in the loop. Let’s build the future — faster, smarter, together. "
    }, {
    "id": 12,
    "url": "https://blog.magicblock.gg/solana-plugin-vrf/",
    "title": "Introducing the Verifiable Randomness Solana Plugin",
    "body": "2025/04/08 - In blockchain applications, getting truly random numbers is surprisingly difficult. Whether building games, raffles, or fair selection mechanisms, you need randomness that everyone can trust—something traditional coding approaches can’t provide. Today, we’re unveiling our solution: The Verifiable Randomness Function (VRF), a Solana Plugin. This new capability is available to all developers building on Solana, with even greater performance and speed when combined with MagicBlock’s Ephemeral Rollups. This update is the next feature announced in our rollout of Solana Plugins, which extends Solana’s capabilities with powerful new functions while maintaining full composability with the ecosystem. Why Is True Randomness So Hard in Blockchain?: Generating true randomness in blockchain environments faces several key challenges:  Everything must be predictable: Blockchains need all validators to reach the same conclusion, but randomness is unpredictable by nature.  Trust issues: The system isn’t fair if anyone can predict or influence “random” numbers.  Proving fairness: Users need to know that random selections weren’t manipulated.  Speed matters: External solutions are often slow and break the seamless user experience. Most existing solutions force developers to compromise on one or more of these requirements. The Verifiable Randomness Solana Plugin: Simple but Powerful: The Verifiable Randomness Solana Plugin solves these challenges with an elegant approach:  Your application requests a random number A network of independent oracles collaborates to generate the randomness Mathematical proofs verify that the result is truly random and unmanipulated The verified random value becomes available in your applicationThe process happens quickly and directly within MagicBlock’s infrastructure, without external services or complex integrations. VRF + Ephemeral Rollups: A Performance Breakthrough: While the Verifiable Randomness Plugin works well on standard Solana, it truly shines when combined with MagicBlock’s Ephemeral Rollups. Here’s why: Physical proximity advantage = low latency: When VRF oracles are co-located with your Ephemeral Rollup, the physical distance that data needs to travel is dramatically reduced. Instead of requests and responses traveling across the internet to external oracle networks, they move within the same infrastructure—reducing latency from seconds to milliseconds. Architectural efficiency = lower gas fees: Our integrated approach requires just a single transaction. This reduces gas costs and complexity, making randomness more affordable and straightforward to implement in your applications. Customizable environment = faster block times: Ephemeral Rollups allow you to configure faster block times and dedicated compute resources tailored to your application. This means you can process randomness requests in an environment optimized for your specific needs rather than competing with other traffic on the base chain. For applications where randomness is a critical component—like real-time games or high-frequency mechanisms—these performance advantages become a game-changer, enabling experiences that wouldn’t be possible with traditional approaches. Real-World Applications: Here are some ideas of what becomes possible with the Verifiable Randomness Solana Plugin: For Games &amp; NFTs  Fair loot drops and rewards Random game elements and encounters NFT trait generation during minting Fair winner selection for competitionsFor DeFi &amp; Governance  Random validator or committee selection Fair distribution of limited opportunities Lottery and raffle mechanismsGetting Started is Easy: Ready to add verifiable randomness to your Solana application? The process is simple:  Build your application using MagicBlock’s Ephemeral Rollups Enable the Verifiable Randomness Solana Plugin Use our straightforward SDK to request and use random valuesOur GitHub repository provides comprehensive documentation and examples for developers who want to explore technical details. Beyond Randomness: The Future of Solana Plugins: The Verifiable Randomness Solana Plugin is just the beginning of what’s possible with our plugin architecture. We’ve already launched additional plugins that enhance what developers can build on Solana:  Pricing Oracle Plugin: Get real-time, low-latency price feeds directly in your applications AI Oracle Plugin: Integrate AI capabilities into your on-chain logic without external dependenciesEach Solana Plugin addresses a key capability gap in the ecosystem, providing developers with powerful tools that simplify building advanced applications. Start Building with Solana Plugins Today: By using Solana Plugins powered by MagicBlock’s Ephemeral Rollups, developers can focus on freely building innovative experiences without worrying about complex infrastructure challenges. Verifiable randomness is a foundational building block for the next generation of decentralized applications, and now, it’s natively available on Solana through our plugin system. Ready to explore randomness for your application? Check out our GitHub repository for everything you need to get started including technical documentation, implementation examples. Stay tuned as we continue expanding the Solana Plugins ecosystem with more powerful capabilities in the months ahead! "
    }, {
    "id": 13,
    "url": "https://blog.magicblock.gg/supersize-hackathon/",
    "title": "From Hackathon Winner to Fully On-Chain Pioneer – How Lewis Built Supersize",
    "body": "2025/03/27 - For many builders, hackathons are more than just competitions—they can be a launchpad for ideas to turn into real, successful projects. Case in point: Lewis Arnsten, co-founder of Supersize, a fully on-chain, real-money casual game that is powered by MagicBlock to create fast, seamless multiplayer experiences. Before winning the Gaming Track at Colosseum, Lewis had a rough prototype and a vision. A few weeks later, he had validation, momentum, and early users testing his game. If you’re considering joining a hackathon, Lewis’ story is proof that it’s worth taking the leap. Also…In case you missed it, we have just announced the Real-Time Hackathon, here to bring your big idea to life. From Idea to Winning a Hackathon: Lewis’ journey into fully on-chain gaming wasn’t a straight path. He had been experimenting with on-chain mechanics for a while, frustrated by the limitations of centralized servers in multiplayer games.  “I thought it would be cool to make Agar. io where you could just wager money, and when you ate, you could eat free money and take people’s money. I thought it was a cool idea. ” But turning that cool idea into a real, scalable game required a foundation that could support real-time transactions and trustless wagering. Lewis explored different blockchain solutions before settling on Solana and MagicBlock’s ephemeral rollups, which provided the low latency and composability he needed. By the time Colosseum rolled around, Lewis had an MVP running on Devnet but needed a space to test, refine, and prove the concept.  “I had an MVP but hadn’t launched on mainnet yet. It was just on devnet… I think I got it onto mainnet right around the time the hackathon ended, and I had a bunch of early users running tests. ” Colosseum gave him the structure to focus, the pressure to ship, and the right audience to validate his idea. The Hackathon Winning Formula: What Made Supersize Stand Out?: Winning a hackathon isn’t just about building something cool—it’s about presenting a technically sound, clearly differentiated project with long-term potential. For Supersize, the key factors were::  ✅ A working prototype – Even though it wasn’t perfect, it was live, interactive, and showed the core mechanics.  ✅ Clear innovation – It wasn’t just a game; it was one of Solana’s first fully on-chain, real-money multiplayer games.  ✅ Strong storytelling – Lewis backed his technical execution with a clear thesis on why fully on-chain gaming mattered and how it could scale.  “We won the gaming track… I think it was a mix of proving our engineering capability, having a real-time fully on-chain game that worked, and having a clear thesis on how we wanted to monetize these casual games. ” Lewis’ Tips for Hackathon Success: Having been through multiple hackathons, Lewis has a few key takeaways for anyone thinking about joining one:  Start Before the Hackathon     “I knew what I wanted to build before it started… I already had the foundations, so I could focus on refining it rather than starting from scratch. ”While many people start their projects during the hackathon, having an idea and some early progress can give you an edge. Even if you don’t have working code, thinking through your concept beforehand helps you move faster once the competition begins.     Have a Prototype People Can Use     “When the judges came to test it, everything worked, and it was the first real-time fully on-chain game. That helped a lot. ”A working prototype is 10x more compelling than just an idea. Even if your project is rough, buggy, or incomplete, showing that it works in some form goes a long way.     Tell a Compelling Story     “A lot of teams were building fully autonomous worlds, but we had a different approach. We showed why casual, real-money games make sense on-chain. ”     Judges and potential supporters aren’t just looking at the tech—they want to see the why behind your project. What problem are you solving? Why does your approach matter? How could it scale beyond the hackathon?   Use Hackathons to Build Relationships     “I found my co-founder after the hackathon, and that’s been huge. ”    Winning is great, but one of the biggest benefits of hackathons is the network you build. Whether it’s meeting potential co-founders, getting feedback from experienced builders, or connecting with investors, hackathons can open doors far beyond the competition itself. Thinking About Joining a Hackathon? Here’s Why You Should: If you’ve been thinking about building something, a hackathon is one of the best ways to test your idea, push yourself to ship, and get honest feedback.  “I feel like I was kind of lucky because I started early and knew exactly what I wanted to build… but the biggest thing was just putting it out there and seeing how people responded. ” Hackathons aren’t just about prizes. They’re about validation, momentum, and opportunities. If you want an opportunity to bring your game idea to life, check out MagicBlock’s Real-Time Hackathon. The gaming track is designed to help builders explore real-time multiplayer mechanics, low-latency transactions, and fully on-chain game economies. It’s also the perfect lead-up to Colosseum—giving you a chance to test ideas, refine your project, and enter Solana’s biggest hackathon with a head start. 👉 Sign up for MagicBlock’s Real-Time Hackathon here. "
    }, {
    "id": 14,
    "url": "https://blog.magicblock.gg/pythlazer/",
    "title": "MagicBlock x Pyth Lazer: Real-time DeFi can now compete with CeFi",
    "body": "2025/02/27 - Today, we’re excited to announce a strategic partnership between MagicBlock and Pyth to bring 1ms price feeds to all Solana dApps. By combining MagicBlock’s high-performance network infrastructure with Pyth Lazer’s financial data feeds, we are unlocking new possibilities for institutional-grade DeFi applications that demand speed, accuracy, and deep liquidity. At MagicBlock, our mission is to empower developers with the fastest, most scalable execution environments in Web3. Pyth Lazer’s high-fidelity, real-time data feeds provide an essential component for DeFi applications, ensuring that traders and protocols have access to the best available market data without relying on centralized sources.  “MagicBlock’s ephemeral rollups enable us to deliver the lowest-latency, high-performance trading experiences, while Pyth Lazer ensures that our partners have the most accurate real-time data. Together, we’re eliminating the barriers to high-performance DeFi and we are paving the way for institutional-grade products. ” – Andrea Fortugno, Co-Founder of MagicBlock Revolutionizing On-Chain Finance: Latency and unreliable data sources are two of the biggest challenges facing decentralized finance. DeFi protocols require execution speeds comparable to traditional finance while maintaining transparency and security. By integrating with Pyth Lazer, MagicBlock delivers:  Real-Time Price Data: 1ms price feed and Ephemeral Node colocation ensure that financial data remains as granular as possible Seamless Composability: Builders can integrate Pyth Lazer’s data feeds into MagicBlock-powered applications without additional bridges or intermediaries.  Scalability for Institutional Use: MagicBlock’s elastic transaction processing enables scalable DeFi applications to support institutional-grade trading volumes. A Shared Vision for the Future of DeFi: MagicBlock and Pyth share a vision of a decentralized financial ecosystem that rivals the speed and reliability of traditional markets. With this partnership, we’re equipping builders with:  Reliable, decentralized financial data for trading apps, spot and derivatives protocols.  Optimized transaction execution that scales dynamically to meet network demand.  Security, verifiability and transparency of fully onchain apps built on Solana “Pyth Lazer’s integration with MagicBlock represents a breakthrough for DeFi infrastructure. By combining Pyth Lazer’s millisecond-latency price feeds with MagicBlock’s ultra-fast execution environment, Solana developers have the tools to build apps that match the performance of traditional markets and have the potential to create the next generation of finance. ” – Abhimanyu Bansal, Head of BD at Douro Labs This collaboration is a call to DeFi builders everywhere: the future of finance is real-time, data-driven, and unstoppable. With MagicBlock and Pyth, the next generation of decentralized financial applications is here. Unleash the Power of MagicBlock &amp; Pyth Lazer: Join us in shaping the future of high-performance DeFi. Explore our documentation. Explore our documentation, or follow us on Twitter (X), Discord to stay in the loop. Let’s build the future — faster, smarter, together. "
    }, {
    "id": 15,
    "url": "https://blog.magicblock.gg/jito/",
    "title": "MagicBlock x Jito: Enhancing Security for Realtime Decentralized Applications on Solana ",
    "body": "2025/02/19 - Today, we’re thrilled to announce our partnership with Jito Network to integrate their restaking solution, strengthening the security of realtime, decentralized applications on Solana. MagicBlock is a realtime network extension that enables developers to build performant fully onchain applications, from FOC games to high-frequency DEXes that can rival centralized trading venues. Developers can now implement the entire logic of their apps on Solana and execute computations - that would traditionally run on centralized servers— in a specialized, temporary environment called an “Ephemeral Rollup,”. developers can achieve the same performance of traditional servers while avoiding single points of failure. This allows for persistent, composable, and verifiable applications that operate at the speed and scale needed for realtime, decentralized applications. By integrating Jito (Re)staking and slashing, MagicBlock is adding an important layer of economic incentives that accelerate decentralization and enhances the security of the network.  “Our goal at MagicBlock has always been to supercharge Solana’s capabilities while avoiding the fragmentations of L2s. Ephemeral Rollups give developers superpowers and additional optionality to build and scale Real-time apps on Solana, and this partnership with Jito allows us to secure and decentralize the network even further. ”– Andrea Fortugno, Co-Founder of MagicBlock Unlocking Better Economic Incentives for Solana Builders: Jito’s restaking infrastructure is designed to enable staked assets to secure multiple networks or services, thereby increasing their security and contributing to the overall robustness of these systems. Through this partnership, MagicBlock developers can now benefit from:  Enhanced Security: Restaking allows staked assets to secure Ephemeral Validators, who are kept accountable for their stake and must behave correctly to avoid getting slashed.  Increased Economic Utility: By participating in restaking, users and tokenholders can unlock additional value from their assets, leading to an extra layer of economic incentives.  Seamless Integration: The restaking framework integrates with existing developer workflows without added complexity, allowing for flexible, secure and scalable ER sessions that can easily manage staked assets.  “We’re excited about exploring Solana scaling solutions and the types of use cases they unlock for application developers,” says Hayden Tsutsui (business development, (re)staking). “By integrating Jito (Re)Staking, the main benefit of this partnership is two-fold: (1) MagicBlock’s engine and ephemeral rollups will remain tethered to the base layer, and (2) Jito Network and its set of node operators will continue to push the boundaries of providing a secure foundation for use cases beyond the L1. ” A Shared Vision for Performance &amp; Decentralization: We believe that Web3 should match the performance of Web2, without sacrificing decentralization. This collaboration isn’t just about enhancing security—it’s about empowering developers with superpowers, allowing them to build secure, realtime applications directly on Solana while avoiding the fragmentations of L2s and single-point-of-failures of web2 infrastructure. Over the coming months, we’ll explore in detail the different modules related to the network security, including releasing staking and restaking functionalities—stay tuned. "
    }, {
    "id": 16,
    "url": "https://blog.magicblock.gg/flashtrade/",
    "title": "MagicBlock x Flash Trade: Accelerating the Future of High-Performance DeFi",
    "body": "2025/02/01 - Today, we’re thrilled to announce a transformative partnership with Flash Trade, Solana’s leading asset-backed perpetuals exchange. Together, we’re setting a new standard for DeFi, delivering lightning-fast trading experiences that redefine the boundaries of speed and composability. At MagicBlock, we empower builders to create without compromise—enabling performance that rivals traditional finance while embracing the trustless, decentralized ethos of Web3. By joining forces with Flash Trade, we’re unlocking the potential for a Binance-like exchange built entirely on Solana!  “MagicBlock’s cutting-edge network infrastructure gives us the power to deliver on our vision: a CEXY trading experience that matches the speed of Web2 exchanges while staying true to the decentralized principles we believe in. ” – Anas, Co-Founder of Flash Trade. MagicBlock Ephemeral Rollups technology empowers Flash Trade to deliver:  Real-Time UX: Sub-50ms latency for a trading experience that feels as intuitive as any Web2 platform.  Unfragmented Liquidity: Keep users entirely within the Solana ecosystem—avoiding bridges and maintaining the full potential of composability.  Dynamic Scalability: Elastic transactions per second (TPS) to handle even the most extreme demand without missing a beat. With MagicBlock’s real-time network powering Flash Trade, high-frequency traders and institutional players alike can experience decentralized trading that meets the performance and expectations of centralized solutions. Shared Ambition, Limitless Potential: Together with the team at Flash Trade, we share a bold vision: to make decentralized finance as fast as centralized exchanges. By overcoming fragmentations and scalability challenges, we’re enabling builders to dream bigger and achieve more. With our real-time network, dynamic co-location, and cutting-edge runtime extensions, MagicBlock ensures that DeFi developers can build experiences that are as reliable as they are groundbreaking. Equipping Builders for What’s Next: At MagicBlock, we’re not just solving for speed; we’re sparking possibility. Our ephemeral roll-up technology ensures developers have the tools they need to scale, innovate, and deliver with confidence. What this means for builders:  Unwavering Reliability: Consistent performance, no matter the network conditions.  Enhanced Ecosystem Connectivity: Seamless composability with Solana’s liquidity-rich environment.  Freedom to Innovate: Remove the technical roadblocks holding you back—build boldly, experiment fearlessly, and launch faster.  “We are excited to put our technology to the service of one of the sleekest on-chain dex to supercharge its capabilities even more. Flash Trade can shape the next generation of decentralized perpetual exchanges. ” - Andrea Fortugno, Co-Founder of MagicBlock This partnership is more than just a collaboration; it’s a call to developers everywhere: the future of DeFi is ready to be built, and with MagicBlock, the possibilities are boundless. Together with Flash Trade, we are making what once seemed impossible, inevitable. Unleash the Power of MagicBlock: Get ready to explore new horizons of performance and innovation in decentralized finance. Explore our documentation, or follow us on Twitter (X) and Discord to stay in the loop. Let’s build the future—faster, smarter, together. "
    }, {
    "id": 17,
    "url": "https://blog.magicblock.gg/ephemeral-validator/",
    "title": "Open Sourcing the MagicBlock Ephemeral Validator",
    "body": "2024/12/12 - Today, we’re excited to announce the open sourcing of the MagicBlock Ephemeral Validator, a non-voting and lightweight SVM-runtime that brings real-time, elastic compute to Solana.  TLDR: You can now write your entire Web2 server logic on Solana and execute arbitrary account updates on Just-In-Time (JIT) SVM instances, which run in parallel with Solana and replace centralized servers. Ephemeral Validators are designed to to use the SVM as a serverless, elastic compute environment for real-time use cases while keeping all smart contracts and state on Mainnet. Forget traditional servers. Just build on Solana and use MagicBlock to access real-time, elastic compute when you need it. Why We Built It: Short version: to bring real-time, **elastic compute ** to Solana. Long version: We believe Solana will become the kernel for global finance. As applications mature and users demand real-time interactions, we see the potential to unlock new experiences that are natively composable with Solana state and run entirely on the SVM instead of a centralized server. While Solana provides exceptional throughput, use cases such as fully onchain games, decentralized social networks or trustless high-frequency financial products require even more scalability. With Ephemeral Rollups, developers can implement the entire logic of these apps on Solana and execute computations that would normally run on a server in a temporary, specialized SVM environment, gaining persistence, composability and verifiability for their applications. What Is the MagicBlock Ephemeral Validator?: The MagicBlock Ephemeral Validator is a non-voting, lightweight SVM-runtime that clones accounts and programs just-in-time (JIT) and settles state to a reference cluster. An Ephemeral validator can run as close as possible to the users to reduce networking latency and it can be run as a sidecar to the Mainnet Validator Clients, standalone or by users themselves given the lowered hardware requirements. Node operators can increase their profitability processing the transactions that would otherwise be implemented in a traditional server or would make little sense to run on Mainnet because they are uneconomical or for latency &amp; runtime limitations. There are 3 main components that the Ephemeral Validator interface with The Ephemeral execution environment: Ephemeral validators don’t participate in consensus nor can create new Accounts. Ephemeral Validator can only process state transitions on accounts delegated to the delegation program. Once an account has been delegated onchain, the Ephemeral Node clones the account and all the programs associated with it. The delegated state is natively locked on Solana and can be modified in the Ephemeral environment. Since the consensus is postponed to the commitment stage, the slot time can be arbitrarily short. Transactions are processed on a first-come-first-served (FCFS) basis and intra-slot updates allow users to subscribe to real-time data, minimising end-to-end latency. Ephemeral rollups open a new design space to scale elastically, where ordering and sequencing can be implemented as part of the smart contract logic. Additionally, even the same smart contract can dynamically execute some instruction in the ER (a fast-pace action), while some other on mainnet (e. g. depositing liquidity, doing a swap, minting, dispatching a reward, . . ). Lastly, the ability to run dedicated runtime leaves the design space open for further customization for application specific use-cases (e. g. a free ticking or randomness) that wouldn’t be possible or make sense to run on Mainnet.  A supercharged development environment: The Ephemeral Validator has been optimized for execution and it can be used as a supercharged development environment. Check out luzid. app if you want to develop at blazing speed! What’s Next: By open-sourcing the validator, we aim to foster collaboration among developers and accelerate adoption of real-time onchain applications. This release is just the beginning. In the coming months, we plan to:  Introduce further optimizations to enhance the validator’s performance.  Provide more in-depth documentation and tutorials for developers.  Launch community initiatives, including hackathons and grantsJoin the Conversation: We’re thrilled to share this milestone with you and can’t wait to see what the community builds with the MagicBlock Ephemeral Validator. Share your thoughts, feedback, and projects with us on Twitter, Discord, or GitHub. "
    }, {
    "id": 18,
    "url": "https://blog.magicblock.gg/zeebit/",
    "title": "Zeebit: Transparent and provably fair games of chance",
    "body": "2024/10/18 - Zeebit is a gaming platform (available at Zeebit. io ) focused on delivering a wide range of games of chance. The mantra of Zeebit has always been providing Web2-like user experiences, while being transparent, permissionless, fair and self-custodied. Despite its obsessive focus on users, Zeebit’s growth was hampered significantly earlier this year as a result of Solana’s congestion. Zeebit’s users could hardly land transactions. Even in scenarios where the network was not degraded, users’ interactions can take anywhere between 0. 5s to 1. 5s – significantly slower than the off-chain products Zeebit is competing with. Challenge: Web2-Like UX with Solana Liquidity: To achieve its goal of delivering a decentralized and provably fair experience, Zeebit needed a solution that could:  Provide a fast, seamless user experience without the typical friction associated with blockchain transactions, like gas fees and transaction delays.  Maintain composability with Solana liquidity and interact seamlessly with the wider Solana ecosystem.  Scale to support a growing number of players, ensuring consistent real-time performance even as demand increased. Traditional L2 approaches lead to liquidity fragmentation and increased user friction, both of which run counter to Zeebit’s objective of a Web2-like experience. Solution: Delegating into Ephemeral Rollups for Every Game interaction: To meet these challenges, Zeebit makes use of Ephemeral Rollups to power its games. From a user perspective, Ephemeral Rollups allow Zeebit to built the following flow:  Players allocate funds to a smart contract account on Solana, signalling the intent to play.  During game play, some transactions are offloaded to the ephemeral validator for real-time interaction – ensuring that game logic can be processed with minimal latency.  The experience is seamless and gasless – as Zeebit is acting as fee payer in the ephemeral node, giving players the fluid experience they expect without compromising decentralization.  When the game ends, a game state gets committed on Solana where the payout happens, preserving liquidity and ensuring player funds remain on the L1. By delegating each game into Ephemeral Rollups, Zeebit was able to achieve web2-like performance while maintaining the composability benefits of Solana. Results: An Immersive, Gasless, Fully On-Chain Experience: With MagicBlock’s Ephemeral Rollups, Zeebit successfully bridged the gap between Web2 performance and fully on-chain decentralization, achieving:  Web2-like User Experience: Thanks to Ephemeral Rollups, Zeebit players enjoy a fast, gasless, and uninterrupted gaming experience that feels identical to traditional online games.  Solana Liquidity and Composability: Zeebit’s games are on Solana, allowing them to leverage all the existing tokens and smart contracts without fragmentation or bridging.  Scalability: The architecture scales seamlessly as the number of concurrent players grows, maintaining real-time interactivity without compromising performance.  Modularity: Zeebit can introduce new game features and integrate with additional Solana primitives quickly and efficiently, keeping their gaming experiences fresh and engaging.  “When congestion first hit, the project really took a major blow. While the situation did improve, it was clear the promise of perpetually and consistently high speed and low cost transaction may no longer be guaranteed on Solana Mainnet. MagicBlock’s Ephemeral Rollup model was a game-changer in enabling Zeebit’s vision. Web3 security and transparency with web2 UX was always Zeebit’s mandate, and MagicBlock is a key enabler of this mission. ” Bayes, Zeebit founder  “Zeebit built an extremely interesting use case that shows the interplays between Solana and Ephemeral Rollups. In order to launch successful dapps at scale we need the same attention to details and focus that Zeebit has for its product and we are proud to help them achieve this without leaving Solana ” — Andrea Fortugno, MagicBlock cofounder &amp; CEO About MagicBlock: MagicBlock is a high-performance engine for fully onchain games and applications. With Ephemeral Rollups, MagicBlock empowers developers to build real-time and composable decentralized applications. "
    }, {
    "id": 19,
    "url": "https://blog.magicblock.gg/supersize/",
    "title": "Supersize: a next-gen real-time PvP game on Solana",
    "body": "2024/10/04 - Supersize is a next-generation gaming platform (available at Supersize. gg) pushing the boundaries of fully onchain gaming on Solana with a simple, powerful vision: financial markets meet . io style game. Supersize is developing a real-time multiplayer experience where users compete for resources in a customizable PvP setting. The game is built entirely onchain (state and logic) and blends financial incentives, UGC and the simplicity of agar. io to create truly innovative game dynamics. The challenge? Creating an entirely onchain experience that could run with real-time latency and impeccable UX without composability fragmentation. Challenge: real-time latency without fragmenting Solana liquidity and state: Supersize required a framework that could handle:  Real-time latency for an ever growing number of concurrent players Composability with Solana liquidity and smart contracts Seamless user experience despite all interactions being onchain transactionsSupersize knew that traditional L2 architecture would struggle to meet these needs due to well-known issues of liquidity fragmentation and the inability to offer consistent real time latency to a globally distributed audience. Solution: Leveraging BOLT ECS + Ephemeral Rollups: Supersize turned to MagicBlock and leveraged BOLT ECS (Entity-Component-System) and Ephemeral Rollups to bring its vision to life. BOLT is an ECS framework built on top of Anchor that enabled Supersize to efficiently structure game logic on Solana, leaving space for the introduction of new systems to extend and modify the game. MagicBlock’s Ephemeral Rollups provided the low-latency performance needed for real-time interactions, while keeping liquidity and all the smart contract on Solana. Additionally, by means of co-location, Ephemeral Rollups further reduce the networking latency (~30ms end-to-end) offering performances on par with traditional multiplayer game servers. Results: A Seamless, Fully On-Chain Gaming Experience: Using BOLT ECS and Ephemeral Rollups, Supersize was able to deliver a fully onchain game that matched all their criteria with:  High scalability and real-time latency: Supersize can elastically scale to support more players who interact with each others in real-time Solana liquidity and composability: the game is built on Solana and can leverage SOL, BONK, LST or any other token without bridging.  Modularity: Supersize can compose with any smart contract and rapidly introduce new game mechanics or upgrades without having to redeploy the entire game architecture.  UX: Thanks to Ephemeral Rollups the gameplay is fast and offers players a seamless, gasless and uninterrupted experience.  Coming from EVM, I was ready to make big compromises to build Supersize fully onchain. But, by leveraging Magicblock’s stack to build directly on Solana, not only does Supersize not compromise on UX, but it also synergizes elegantly with the broader Solana ecosystem. ” Lewis Arnsten, Supersize founder  I am extremely excited to see Supersize advancing the narrative of what is possible with FOCG. I am extremely bullish on Solana-first experiences that tap into the liquidity and existing primitives of the chain without sacrificing a seamless user experience” Andrea Fortugno, MagicBlock cofounder &amp; CEO About MagicBlock: MagicBlock is a high-performance engine for fully onchain games and applications. With Ephemeral Rollups, MagicBlock empowers developers to build real-time and composable decentralized applications. Learn more at MagicBlock. "
    }, {
    "id": 20,
    "url": "https://blog.magicblock.gg/enable-real-time-onchain-games-and-applications/",
    "title": "MagicBlock Has Raised $3M to Enable Real-Time Onchain Games and Applications",
    "body": "2024/09/17 - MagicBlock’s Ephemeral Rollups technology is designed to provide web2-like performance to Solana developers and enable the creation of trustless, unstoppable games and applications on Solana. The company has now raised a total of $3 million in pre-seed funding to scale its engine for real-time onchain games and consumer applications on Solana. MagicBlock was in the Spring 2024 cohort of the a16z Crypto Startup Accelerator (CSX) program, and secured funding from a16z CSX in conjunction with its participation. MagicBlock was founded to address the limitations of current onchain applications, which struggle with performance and scalability. In contrast to Ethereum Layer 2 solutions, which often introduce fragmentation and a poor user experience due to liquidity fragmentation and loss of composability, MagicBlock’s Ephemeral Rollups function more like a coprocessor or an extension of Solana. Thanks to the Solana’s Virtual Machine (SVM) native separation of state and logic, developers can move only part of the state to an Ephemeral Rollup session while retaining the core programs on Solana, effectively creating a multi-threaded environment for their dapps. This design ensures seamless composability with Solana and real-time performance, making Ephemeral Rollups ideal not only for gaming but also for any other application requiring high-performance and composability. MagicBlock’s unique approach enables developers to create unstoppable, trustless, and composable applications that can operate without traditional servers, while avoiding the clunky feeling of transaction lags. This funding marks a significant milestone in MagicBlock’s journey. With the new funding, MagicBlock aims to expand its team, developer outreach and technology development. This raise is a testament to the growing demand for truly decentralized, high-performance applications in the web3 industry. "
    }, {
    "id": 21,
    "url": "https://blog.magicblock.gg/luzid/",
    "title": "Introducing Luzid: Solana Development at Light Speed",
    "body": "2024/07/03 - We are thrilled to release the latest version of Luzid, an essential tool for anyone building on Solana, no matter if you are a seasoned developer or just starting out. What is Luzid?: Luzid embeds a blazingly fast test validator and provides enhanced insights into your transactions including account diffs. It clones programs and accounts on demand, enables persistent state via snapshots and account state mutation in order to ease test setup. Finally its workspace discovery feature has you up and running with all your local programs loaded in no time. Key Features of Luzid: 1. Develop at the Speed of Light: Luzid embeds a validator optimised for speed. Developers will be more productive as a result as the turnaround time from code change to test completion is cut drastically. We’ve seen 16x speedup for some test suites when compared to running them via the stock Solana test validator. 2. Flexible State Management: Luzid enables developers to mutate account states via its powerful SDK. This is an essential feature to set up test scenarios quickly. Luzid’s snapshot makes it easy to persist and restore state repeatedly to test multiple actions based on it. Snapshots can persist and be restored across Luzid sessions. 3. Workspace Discovery and On Demand Program Cloning: At startup Luzid will scan your workspace and automatically load all your programs into thevalidator. Each time you apply a change to your program, Luzid will hotswap it into the already running validator without requiring a program redeploy or validator restart. If Luzid encounters a program as part of a transaction it does not know about it will automatically clone it from the specified Solana cluster, i. e Devnet or Mainnet. This makes it easy to test transactions locally without any additional setup. 4. Account Diff Visualisation: Luzid discovers IDLs for programs loaded from a workspace or cloned on demand. This enables it to show not only parsed account data, but also to provide visual diffs for eachaccount that was modified as part of a transaction. This powerful feature makes it much easier for developers to understand what each transaction is doing and to diagnose issues. When an IDL for a program cannot be found Luzid will provide account diffs in a raw formatwhich is very useful to understand how some programs work under the hood. 5. Seeing is Believing: In order to truly appreciate the boost to your productivity that Luzid provides we recommendyou to give it a try following these simple steps:  Download Luzid following the Luzid Getting Started guide Navigate to your workspace directory in a terminal Launch Luzid in workspace discovery mode via luzid .  Open the Luzid UI (LuzidUI. app on MacOS) and start developingJoin our developer Community: Luzid is an open-source tool developed by MagicBlock and available for the whole Solana developer community; For a comprehensive overview of Luzid and to see it in action, watch the introductory video on YouTube. Join the MagicBlock discord to learn how to make the most out of Luzid and stay up-to-date with the latest developments. "
    }, {
    "id": 22,
    "url": "https://blog.magicblock.gg/bolt-tic-tac-toe/",
    "title": "Tic-Tac-Toe with Reusable Components and Customizable Logic",
    "body": "2024/04/06 - In this article, we showcase a simple game example developed using the Bolt Entity Component System (ECS), which facilitates reusability of components and enables users to modify and extend the game’s logic. The framework significantly simplifies Solana development by abstracting low-level concepts such as account space and Program Derived Addresses (PDAs). For comparison with an Anchor-based program, refer to this tutorial. For a more detailed explanation of Bolt, see the announcement blog post. Implementing Tic-Tac-ToeThe first section of this post details the implementation of the game logic using the Bolt framework. The second section explains how to integrate a React-based client with the program, starting with an open-source Tic-Tac-Toe implementation. The complete source code of the example is available here. The Game Logic: Implementing Tic-Tac-Toe with the Bolt ECS: First, install the bolt-cli with: npm install -g @magicblock-labs/bolt-cliOnce installed, create a new project with: bolt init tic-tac-toeCreating the Components: We need to define the data structures required. For simplicity, we will create two components: one containing the active players and the other containing the grid information. Create a new components with: bolt component playersThis command creates a players component under program-ecs/components. The players component, which holds the public keys of the two players, can be defined as follows: use bolt_lang::*;declare_id!( 5Xz6iiE2FZdpqrvCKbGqDajNYt1tP8cRGXrq3THSFo1q );#[component]#[derive(Default)]pub struct Players {  pub players: [Option&lt;Pubkey&gt;; 2],}The second component contains the grid information. Create it with: bolt component gridThe grid component can be defined as: use bolt_lang::*;declare_id!( rdiVoU6KomhXBDMLi6UXVHvmjEUtKqb5iDCWChxMzZ7 );#[component]pub struct Grid {  pub board: [[Option&lt;Sign&gt;; 3]; 3],  pub state: GameState,  pub is_first_player_turn: bool,}#[component_deserialize]#[derive(PartialEq)]pub enum GameState {  Active,  Tie,  Won { winner: Pubkey },}#[component_deserialize]#[derive(PartialEq)]pub enum Sign {  X,  O,}impl Sign {  pub fn from_usize(value: usize) -&gt; Sign {    match value {      0 =&gt; Sign::X,      _ =&gt; Sign::O,    }  }}impl Default for Grid {  fn default() -&gt; Self {    Self::new(GridInit{      board: [[None; 3]; 3],      state: GameState::Active,      is_first_player_turn: true,    })  }}Creating the Systems: Systems implement the game logic in a modular fashion. They operate on a bundle of input components and can perform any computation. Systems are executed in your world instance subject to the approval policy, e. g. , a world could allow anyone to submit new systems, while another could require approval from whitelisted parties or a DAO. The first system we build will allow a player to join a match: bolt system join-gameModify the logic (in program-ecs/systems/join-game. rs) to: #[system]pub mod join_game {  pub fn execute(ctx: Context&lt;Components&gt;, _args_p: Vec&lt;u8&gt;) -&gt; Result&lt;Components&gt; {    let players = &amp;mut ctx. accounts. players. players;    let idx = match players. iter_mut(). position(|player| player. is_none()) {      Some(player_index) =&gt; player_index,      None =&gt; return Err(PlayersError::GameFull. into()),    };    ctx. accounts. players. players[idx] = Some(*ctx. accounts. authority. key);    Ok(ctx. accounts)  }  #[system_input]  pub struct Components {    pub players: Players,  }}The second system implements the core logic of the game:    Create a play system:   bolt system play      Implement the logic:  use bolt_lang::*;use grid::Grid;use players::Players;declare_id!( DyUy1naq1kb3r7HYBrTf7YhnGMJ5k5NqS3Mhk65GfSih );#[system]pub mod play {  pub fn execute(ctx: Context&lt;Components&gt;, args: Args) -&gt; Result&lt;Components&gt; {    let grid = &amp;mut ctx. accounts. grid;    let players = &amp;mut ctx. accounts. players;    let authority = *ctx. accounts. authority. key;    require!(players. players[0] == Some(authority) || players. players[1] == Some(authority), TicTacToeError::NotInGame);    require!(grid. state == grid::GameState::Active, TicTacToeError::NotActive);    let player_idx : usize = if players. players[0] == Some(authority) { 0 } else { 1 };    require!(grid. is_first_player_turn == (player_idx == 0), TicTacToeError::NotPlayersTurn);    // Core game logic    match args {      tile @ Args {        row: 0. . =2,        column: 0. . =2,      } =&gt; match grid. board[tile. row as usize][tile. column as usize] {        Some(_) =&gt; return Err(TicTacToeError::TileAlreadySet. into()),        None =&gt; {          grid. board[tile. row as usize][tile. column as usize] =            Some(grid::Sign::from_usize(player_idx));        }      },      _ =&gt; return Err(TicTacToeError::TileOutOfBounds. into()),    }    grid. is_first_player_turn = !grid. is_first_player_turn;    check_winner(grid, authority);    Ok(ctx. accounts)  }  #[system_input]  pub struct Components {    pub grid: Grid,    pub players: Players,  }  #[arguments]  struct Args {    row: u8,    column: u8,  }}pub fn check_winner(grid: &amp;mut Account&lt;Grid&gt;, player: Pubkey) {  . . . }Refer to the full source code for details. As you can notice, the implementation is incredibly simple. The struct marked with system_input define the components input bundle, that can be accessed and used in the execute function. the struct marked with arguments define the arguments that your system can receive as input. Build and Test the Program: Build the program with: bolt buildThis command compiles the program and generates the IDL and TypeScript types automatically for client integration. The process for setting up components and executing the systems involves the following steps:  Instantiate a world.  Create a match entity.  Attach the players and grid components to this match entity.  Execute the systems to facilitate gameplay. The TypeScript tests for the Tic-Tac-Toe game can be found here: Connect a React Client: Connecting a React client is straightforward, thanks to the dynamic retrieval and generation of types and the utility functions provided by the Bolt TypeScript SDK. Add the dependency with: yarn add -D @magicblock-labs/bolt-sdkFor example, to execute a system: // Componentsconst GRID_COMPONENT = new PublicKey( rdiVoU6KomhXBDMLi6UXVHvmjEUtKqb5iDCWChxMzZ7 );const PLAYERS_COMPONENT = new PublicKey( 5Xz6iiE2FZdpqrvCKbGqDajNYt1tP8cRGXrq3THSFo1q );// Systemsconst JOIN_GAME = new PublicKey( 2umhnxiCtmg5KTn4L9BLo24uLjb74gAh4tmpMLRKYndN );const PLAY = new PublicKey( DyUy1naq1kb3r7HYBrTf7YhnGMJ5k5NqS3Mhk65GfSih );const applySystem = await ApplySystem({  authority: publicKey,  system: JOIN_GAME,  entity,  components: [PLAYERS_COMPONENT],});const transaction = applySystem. transaction;const signature = await submitTransaction(transaction);Find the simple Tic-Tac-Toe UI made in React here: react-tic-tac-toe An important aspect to highlight is that executing systems and instantiating components require only the ID. This means that new logic and data structures can be created and utilized dynamically, enabling the development of mods and alterations to your game’s behavior. Conclusion: We have walked through a simple implementation of a Tic-Tac-Toe game using the Bolt ECS, demonstrating how to connect it to a React UI. This highlights the simplicity and flexibility of the framework. In addition to abstracting Solana and reusing onchain logic, we are excited about the unlocks BOLT will introduce for user-generated logic and mods. In follow-up examples, we will show how a game developer could independently and permissionlessly extend the logic of a game and how to achieve low latency/high troughput transactions using the ephemeral rollups. "
    }, {
    "id": 23,
    "url": "https://blog.magicblock.gg/bolt-v0.1/",
    "title": "BOLT engine: unstoppable and composable games",
    "body": "2024/03/01 - The V0. 1 of BOLT is live. BOLT is an onchain framework that simplifies the development of games that are permissionless, composable and can live forever on the blockchain. The design of BOLT includes an SVM-compatible acceleration layer to bring the performance of FOC games on par with traditional multiplayer game servers, without compromising the composability of Solana’s global state. In this early release we are going through the BOLT CLI and Entity Component System (ECS), addressing the recents updates and showcasing how to set up a simple onchain game on Solana. ✨ The ECS pattern: While Bolt isn’t exclusively an Entity Component System (ECS) framework, we encourage the use of this powerful design pattern to enhance composability. ECS is a way of organizing code and data to enable modular and extendible games, key features we seek while building fully onchain. As the name suggests, in an ECS there are:  Entities that represent the objects of the game world. They are unique identifiers that don’t hold any data or behavior, but simply serve as containers Components are raw data structures that can be “attached” to entities System performs the game logic or behavior by acting upon entities that hold componentsThis separation of concerns enables a highly flexible and modular architecture. You can explore all the benefits of the ECS pattern here. BOLT CLI: The BOLT CLI is an extension of the Anchor framework. It includes all the features of the popular Solana development framework, plus a superset of functionalities for creating world instances, components and systems. Install BOLT: npm install @magicblock-labs/bolt-cliYou can verify the installation with: bolt -hInitialize your first project running: bolt init &lt;new-workspace-name&gt;Components: The example in the programs-ecs/components folder defines a Position component containing x, y, z coordinates. Remember that components are plain data structures that contain data relevant to a specific attribute of an entity. They don’t contain any logic or methods. use bolt_lang::*;declare_id!( Fn1JzzEdyb55fsyduWS94mYHizGhJZuhvjX6DVvrmGbQ );#[component]#[derive(Copy)]pub struct Position {  pub x: i64,  pub y: i64,  pub z: i64,}The #[component] macro is taking care of all the underlying Solana-specific behavior. You don’t have to understand how Accounts work, how to allocate bytes or anything other than defining the data structure. Components are themselves programs deployed onchain. declare_id!( Fn1JzzEdyb55fsyduWS94mYHizGhJZuhvjX6DVvrmGbQ );The id defines the unique address of the component Position above. Systems: Systems contain the logic that manipulates components. A system will typically operate on all entities that have a specific set of components. The system_movement example encapsulates the logic for updating the Position component. use bolt_lang::*;use component_position::Position;declare_id!( FSa6qoJXFBR3a7ThQkTAMrC15p6NkchPEjBdd4n6dXxA );#[system]pub mod system_movement {  pub fn execute(ctx: Context&lt;Components&gt;, args_p: Vec&lt;u8&gt;) -&gt; Result&lt;Components&gt; {    let position = &amp;mut ctx. accounts. position;    position. x += 1;    Ok(ctx. accounts)  }  // Define the input components  #[system_input]  pub struct Components {    pub position: Position,  }}Each system implements an execute instruction, that will take care of applying the system’s logic on an arbitrary number of components. The struct marked with the #[system_input] macro, specifies the bundle of components that the system will receive as input. The execute instruction returns the modified components, which the World Program will update in the data structures after checking permissions and business logic. Again, you don’t need to worry about the underlying blockchain layer by defining the CPI, retrieving the IDL or anything else. Just define the bundle of components you want your system to operate on! Bringing everything together with the World Program: Now that we have a grasp of how components and systems operate, let’s create a game instance with the World Program from the TypeScript SDK. The World Program is the entrypoint for creating world instances, entities, attaching components, and executing systems. The SDK provides a convenient interface and methods for interacting with BOLT. Installation: To install the bolt sdk, run the following command: npm install @magicblock-labs/bolt-sdk --save-dev Create a world instanceconst initNewWorld = await InitializeNewWorld({  payer: provider. wallet. publicKey,  connection: provider. connection,});const tx = new anchor. web3. Transaction(). add(createEntityIx);await provider. sendAndConfirm(initNewWorld. transaction);Add a new entityconst addEntity = await AddEntity({  payer: provider. wallet. publicKey,  world: initNewWorld. worldPda,  connection: provider. connection,});await provider. sendAndConfirm(addEntity. transaction);Attach the Position component to the the entityconst initComponent = await InitializeComponent({  payer: provider. wallet. publicKey,  entity: addEntity. entityPda,  componentId: positionComponent. programId,});await provider. sendAndConfirm(initComponent. transaction);Execute the movement system on the position Componentconst applySystem = await ApplySystem({  authority: provider. wallet. publicKey,  system: systemMovement. programId,  entity: addEntity. entityPda,  components: [positionComponent. programId],});const tx = new anchor. web3. Transaction(). add(applySystemIx);await provider. sendAndConfirm(applySystem. transaction);In this simple example we have created an entity Player that holds a Position component with x,y,z coordinates. We can execute the movement system to change its state. Here’s the best part. By defining your game data structure with the BOLT ECS, you’ll not only be able to reuse existing systems and components, but you can easily allow for mods or extensions of your game. Let’s think of a slightly more sophisticated movement dynamics, with a Velocity component that alters the position defined as: use bolt_lang::*;declare_id!( CbHEFbSQdRN4Wnoby9r16umnJ1zWbULBHg4yqzGQonU1 );#[component]#[derive(Copy)]pub struct Velocity {  pub x: i64}Someone might want to introduce a new power-up for faster movement. They could do this simply by adding a new system that acts on the Position component using Velocity #[system]pub mod system_apply_velocity {  pub fn execute(ctx: Context&lt;Components&gt;, _args: Vec&lt;u8&gt;) -&gt; Result&lt;Components&gt; {    ctx. accounts. position. x += ctx. accounts. velocity. x;    Ok(ctx. accounts)  }  #[system_input]  pub struct Components {    pub position: Position,    pub velocity: Velocity,	  }}Notice how simple this snippet of code is. This new system takes as inputs the Position and Velocity components, and defines the logic of the power-up. There is no notion of Solana accounts or CPI - the proxy World program is taking care of everything here. With a few lines of code and barely any blockchain knowledge, we have just introduced a new game behavior! Summing up: BOLT leverages an ECS pattern to enable game developers to create highly modular, efficient and composable games. Entities serve as containers for components, raw data structure, allowing for dynamic customization without altering the underlying codebase. Systems interact with these components, infusing logic and behavior into the game entities. This separation of concerns not only simplifies the development process, but makes game logic more reusable and enhances the ability to extend and modify games post-launch, in a permissionless fashion. We can’t wait to see the mechanics that will emerge out of this framework. Start building with BOLT here and share your feedback with our community on Discord! "
    }, {
    "id": 24,
    "url": "https://blog.magicblock.gg/session-keys/",
    "title": "Session Keys integrated into the Solana Unity SDK",
    "body": "2023/06/13 - We are thrilled to announce that we have partnered up with Gum and integrated Session Keys into the Solana Unity SDK. Magicblock is a powerful and versatile open-source framework designed for building on-chain games on Solana/SVM. It provides the tools to abstract away a lot of complexity and focus on creating the best experience for users. Solana Unity SDK provides a set of open-source tools to radically simplify the process of building games on Solana. It natively supports wallets, NFTs, DEXes, custom programs and now, Session Keys as well. ✨ This integration will allow game developers on Solana to effortlessly implement sessions in the games they create with Unity. Why on-chain gaming: On-chain gaming is a new exciting category of games where both the game state and logic are stored on-chain. This enables players to enjoy benefits such as easy UGC (User-Generated Content) and UGL (User-Generated Logic) due to the public and permissionless nature of smart contracts. Another benefit of building on-chain is persistence. The game and its progress are preserved indefinitely and the lack of a centralized server opens up the scene to “Autonomous Worlds”, virtual realities owned by the community that can’t be stopped or shut down. Despite all the buzz, a notable challenge is the poor user experience. Due to their nature, every player interaction is a transaction, which leads to incredible friction in gameplay. Sessions to Supercharge Games: Gum has always been at the forefront of simplifying the UX for developers and end-users alike and Solana is perfectly suited for this. Its speed and scalability allow for real-time, interactive gameplay without the worry of network congestion or high transaction fees. Session Keys act essentially as secondary signers in the game. They are used to create ephemeral keypairs and issue session tokens to users, meant for frequent interactions but for a specific session of play. With Session Keys integrated into the Solana Unity SDK, game developers can now build on-chain interactions within a game without having to worry about the UX problems and constant wallet popups that they come with. This is a huge leap in the overall gameplay experience. Session keys also solve the security issues that may arise with an in-game wallet auto-approving all the transactions, because developers can specify a target program for their validity, expiry and scope. The future of on-chain gaming: Gum and Magicblock are excited to work together to trailblaze the next phase of on-chain gaming on Solana and bring this exciting new category into the mainstream. If you are excited about the vision around on-chain gaming, we are organizing Speedrun - the first-ever Game Jam on Solana - where you can compete for the Gum prize for the best Session Keys integration. "
    }, {
    "id": 25,
    "url": "https://blog.magicblock.gg/sec3/",
    "title": "Sec3 and Magicblock Boost Security for On-chain Worlds",
    "body": "2023/05/10 - We are happy to announce a new partnership with Sec3, a leading security research, auditing, and engineering company to enhance the security of the next generation of on-chain games and autonomous worlds. Through the partnership, Magicblock’ developers will be able to gain discounted access for X-ray, an automated smart contracts vulnerabilities scanner as well as manual Launch Audits. WatchTower, a real time on-chain monitoring service, is currently available for free. Blockchains are adversarial environments. As more and more games become fully on-chain experiences with economies deeply entrenched in DeFi markets, the need for reliable monitoring services will only increase. This is where the security expertise of sec3 comes into play, as their suite of products simplifies the monitoring of unusual transactions leveraging the latest research in Artificial Intelligence and Machine Learning. By looking through historical transactions, WatchTower is able to alert of potentially malicious transactions in real time with almost no user input. sec3 is also actively researching ways to curtail and prevent botting within gaming.  As infrastructure providers, we are always looking for ways to help our developers grow their games and improve their workflows. sec3 is an incredible add-on that will provide top-class security and monitoring solutions for fully on-chain worlds. Andrea Fortugno, CEO of Magicblock  We’re excited to collaborate with Magicblock in their pursuit of simplifying web3 game development. Our partnership will enable sec3 to deliver world-class security, auditing, and monitoring solutions that ensure the safety and resilience of on-chain economies and foster innovation in the gaming ecosystem. Chris Wang, CEO of Sec3 This partnership will provide Magicblock’s ecosystem developers with increased confidence in the security and stability of their games. We are thrilled to be working with sec3 to reduce attack vectors and vulnerabilities for the next generation of on-chain gaming. Learn more and sign up to Sec3, using the MAGICBLOCK discount code. "
    }, {
    "id": 26,
    "url": "https://blog.magicblock.gg/datawisp/",
    "title": "Datawisp and Magicblock Partner to Bring No-code Analytics to On-chain Games",
    "body": "2023/05/03 - We’re thrilled to announce a new partnership between Magicblock, core contributor to the Solana Unity SDK, and Datawisp, a no-code analytics platform for game developers. Magicblock’s infrastructure already makes it extremely convenient to build on-chain, permissionless and composable games on Solana. Going forward, game developers using the SDK will also benefit from the collaboration between Magicblock and Datawisp in the form of 1) a more streamlined data analytics process and 2) discounted access to the Datawisp platform once the open beta ends. Datawisp is currently free to all users. Most data-related tasks are complex and require either a data scientist or engineer to complete, even more so when dealing with smart contracts. This can be a problem, especially for small studios with limited resources. Datawisp’s easy to use no-code analytics platform lets anyone track and analyze key metrics on and off chain without needing to write code - freeing up developers to focus on building awesome games! By answering key questions such as “do players who own an NFT play differently than those who don’t?” game developers can make informed decisions that will help them grow their games and retain their players. Andrea Fortugno, CEO of Magicblock  We’re excited to partner with Datawisp to bring their powerful analytics platform to game developers building on Solana. Analytics is a top priority for our users and we believe a no-code approach will enable a more streamlined development experience for on-chain games. Mo Hallaba, CEO of Datawisp  Both Datawisp and the Solana Unity SDK were built to save game developers time and allow them to focus on what matters most, building amazing games. We’re excited to partner up with MagicBlock and contribute to the Solana games ecosystem however we can. We’re extremely bullish on the Solana ecosystem and we are excited to see what innovative games and use cases can emerge from our synergic infrastructures. Learn more and sign up to Datawisp "
    }, {
    "id": 27,
    "url": "https://blog.magicblock.gg/solana-unity-sdk/",
    "title": "The Solana SDK for Unity is available on the Unity Asset Store as a Verified Solution",
    "body": "2023/02/27 - Unity introduced today a new Asset Store category for verified decentralized technologies in gaming, which includes the Solana SDK for Unity by Magicblock. Solana is at the center of this new era of decentralized gaming. Dozens of game teams are building on Solana because Solana is fast, it scales, transaction costs are near zero, and Solana enables mobile apps. No matter if you’re a current game dev looking to enter web3 for the first time or are already familiar with Solana, this new Asset Store category makes finding the Solana SDK for Unity by Magicblock easy. From there, the SDK lets game developers easily integrate Solana-based NFTs, tokens, and on-chain programs within their Unity games, simplifying the process of building web3 games and experiences. The SDK enables wallet connectivity, the easy creation and handling of tokens, and enables easy connections to Solana-based projects. The SDK was created by Magicblock, a web3 studio building on-chain composable games for the mass mobile market. The SDK is already being used by dozens of game studios and Unity’s new decentralized asset store category will help even more game devs to start building on Solana. Find more info about the SDK here and here. "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});


    
function lunr_search(term) {
    $('#lunrsearchresults').show( 1000 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-secondary btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
</script>
<style>
    .lunrsearchresult .title {color: #d9230f;}
    .lunrsearchresult .url {color: silver;}
    .lunrsearchresult a {display: block; color: #777;}
    .lunrsearchresult a:hover, .lunrsearchresult a:focus {text-decoration: none;}
    .lunrsearchresult a:hover .title {text-decoration: underline;}
</style>




<form class="bd-search hidden-sm-down" onSubmit="return lunr_search(document.getElementById('lunrsearch').value);">
<input type="text" class="form-control text-small"  id="lunrsearch" name="q" value="" placeholder="Type keyword and enter..."> 
</form>
            </ul>
        </div>
    </div>
    </nav>

    <!-- Search Results -->
    <div id="lunrsearchresults">
        <ul class="mb-0"></ul>
    </div>

    <!-- Content -->
    <main role="main" class="site-content">
        
<div class="container">
<div class="jumbotron jumbotron-fluid mb-3 pl-0 pt-0 pb-0 bg-white position-relative">
		<div class="h-100 tofront">
			<div class="row  justify-content-between ">
				<div class=" col-md-6  pr-0 pr-md-4 pt-4 pb-4 align-self-center">
					<!-- <p class="text-uppercase font-weight-bold">
                        <span class="catlist">
						
                          <a class="sscroll text-danger" href="/categories.html#announcement">announcement</a><span class="sep">, </span>
                        
                        </span>
					</p> -->
					<h1 class="display-4 mb-4 article-headline">Introducing the Verifiable Randomness Solana Plugin</h1>
					<div class="d-flex align-items-center">
                        
                        <img class="rounded-circle" src="/assets/images/avatar1.png" alt="Magicblock" width="70"/>
                        
						<small class="ml-3"> Magicblock <span><a target="_blank" href="https://twitter.com/magicblock" class="btn btn-outline-success btn-sm btn-round ml-1">Follow</a></span>
                            <span class="text-muted d-block mt-1">Apr 08, 2025 · <span class="reading-time">
  
  
    4 mins read
  
</span>
    </span>
						</small>
					</div>
				</div>
                
				<div class="col-md-6 pr-0 align-self-center">
					<img class="rounded" src="/assets/images/vrf.png" alt="Introducing the Verifiable Randomness Solana Plugin">
				</div>
                
			</div>
		</div>
	</div>
</div>





<div class="container-lg pt-4 pb-4">
	<div class="row justify-content-center">


        <!-- Share -->
		<!-- <div class="col-lg-2 pr-4 mb-4 col-md-12">
			<div class="sticky-top sticky-top-offset text-center">
				<div class="text-muted">
					Share this
				</div>
				<div class="share d-inline-block">
					<div class="a2a_kit a2a_kit_size_32 a2a_default_style">
						<a class="a2a_dd" href="https://www.addtoany.com/share"></a>
						<a class="a2a_button_facebook"></a>
						<a class="a2a_button_twitter"></a>
					</div>
					<script async src="https://static.addtoany.com/menu/page.js"></script>
				</div>
			</div>
		</div> -->


		<div class="col-md-12 col-lg-8">

            <!-- Article -->
			<article class="article-post">
			<p>In blockchain applications, getting truly random numbers is surprisingly difficult. Whether building games, raffles, or fair selection mechanisms, you need randomness that everyone can trust—something traditional coding approaches can’t provide.</p>

<p>Today, we’re unveiling our solution: <strong>The Verifiable Randomness Function (VRF), a Solana Plugin</strong>. This new capability is available to all developers building on Solana, with even greater performance and speed when combined with MagicBlock’s Ephemeral Rollups.</p>

<p>This update is the next feature announced in our rollout of <strong>Solana Plugins</strong>, which extends Solana’s capabilities with powerful new functions while maintaining full composability with the ecosystem.</p>

<h2 id="why-is-true-randomness-so-hard-in-blockchain">Why Is True Randomness So Hard in Blockchain?</h2>

<p>Generating true randomness in blockchain environments faces several key challenges:</p>

<ul>
  <li><strong>Everything must be predictable</strong>: Blockchains need all validators to reach the same conclusion, but randomness is unpredictable by nature.</li>
  <li><strong>Trust issues</strong>: The system isn’t fair if anyone can predict or influence “random” numbers.</li>
  <li><strong>Proving fairness</strong>: Users need to know that random selections weren’t manipulated.</li>
  <li><strong>Speed matters</strong>: External solutions are often slow and break the seamless user experience.</li>
</ul>

<p>Most existing solutions force developers to compromise on one or more of these requirements.</p>

<h2 id="the-verifiable-randomness-solana-plugin-simple-but-powerful">The Verifiable Randomness Solana Plugin: Simple but Powerful</h2>

<p>The Verifiable Randomness Solana Plugin solves these challenges with an elegant approach:</p>

<ol>
  <li>Your application requests a random number</li>
  <li>A network of independent oracles collaborates to generate the randomness</li>
  <li>Mathematical proofs verify that the result is truly random and unmanipulated</li>
  <li>The verified random value becomes available in your application</li>
</ol>

<p>The process happens quickly and directly within MagicBlock’s infrastructure, without external services or complex integrations.</p>

<h2 id="vrf--ephemeral-rollups-a-performance-breakthrough">VRF + Ephemeral Rollups: A Performance Breakthrough</h2>

<p>While the Verifiable Randomness Plugin works well on standard Solana, it truly shines when combined with MagicBlock’s Ephemeral Rollups. Here’s why:</p>

<p><strong>Physical proximity advantage = low latency</strong>: When VRF oracles are co-located with your Ephemeral Rollup, the physical distance that data needs to travel is dramatically reduced. Instead of requests and responses traveling across the internet to external oracle networks, they move within the same infrastructure—reducing latency from seconds to milliseconds.</p>

<p><strong>Architectural efficiency = lower gas fees</strong>: Our integrated approach requires just a single transaction. This reduces gas costs and complexity, making randomness more affordable and straightforward to implement in your applications.</p>

<p><strong>Customizable environment = faster block times</strong>: Ephemeral Rollups allow you to configure faster block times and dedicated compute resources tailored to your application. This means you can process randomness requests in an environment optimized for your specific needs rather than competing with other traffic on the base chain.</p>

<p>For applications where randomness is a critical component—like real-time games or high-frequency mechanisms—these performance advantages become a game-changer, enabling experiences that wouldn’t be possible with traditional approaches.</p>

<h2 id="real-world-applications">Real-World Applications</h2>

<p>Here are some ideas of what becomes possible with the Verifiable Randomness Solana Plugin:</p>

<p><strong>For Games &amp; NFTs</strong></p>

<ul>
  <li>Fair loot drops and rewards</li>
  <li>Random game elements and encounters</li>
  <li>NFT trait generation during minting</li>
  <li>Fair winner selection for competitions</li>
</ul>

<p><strong>For DeFi &amp; Governance</strong></p>

<ul>
  <li>Random validator or committee selection</li>
  <li>Fair distribution of limited opportunities</li>
  <li>Lottery and raffle mechanisms</li>
</ul>

<h2 id="getting-started-is-easy">Getting Started is Easy</h2>

<p>Ready to add verifiable randomness to your Solana application? The process is simple:</p>

<ol>
  <li>Build your application using MagicBlock’s Ephemeral Rollups</li>
  <li>Enable the Verifiable Randomness Solana Plugin</li>
  <li>Use our straightforward SDK to request and use random values</li>
</ol>

<p>Our <a href="https://github.com/magicblock-labs/Ephemeral-VRF">GitHub repository</a> provides comprehensive documentation and examples for developers who want to explore technical details.</p>

<h2 id="beyond-randomness-the-future-of-solana-plugins">Beyond Randomness: The Future of Solana Plugins</h2>

<p>The Verifiable Randomness Solana Plugin is just the beginning of what’s possible with our plugin architecture. We’ve already launched additional plugins that enhance what developers can build on Solana:</p>

<ul>
  <li><strong>Pricing Oracle Plugin</strong>: Get real-time, low-latency price feeds directly in your applications</li>
  <li><strong>AI Oracle Plugin</strong>: Integrate AI capabilities into your on-chain logic without external dependencies</li>
</ul>

<p>Each Solana Plugin addresses a key capability gap in the ecosystem, providing developers with powerful tools that simplify building advanced applications.</p>

<h2 id="start-building-with-solana-plugins-today">Start Building with Solana Plugins Today</h2>

<p>By using Solana Plugins powered by MagicBlock’s Ephemeral Rollups, developers can focus on freely building innovative experiences without worrying about complex infrastructure challenges.</p>

<p>Verifiable randomness is a foundational building block for the next generation of decentralized applications, and now, it’s natively available on Solana through our plugin system.</p>

<p>Ready to explore randomness for your application? Check out our <a href="http://github.com/magicblock-labs/ephemeral-vrf">GitHub repository</a> for everything you need to get started including technical documentation, implementation examples.</p>

<p>Stay tuned as we continue expanding the Solana Plugins ecosystem with more powerful capabilities in the months ahead!</p>


			</article>

			<!-- Tags -->
			<div class="mb-4">
				<span class="taglist">
				
				</span>
			</div>

            <!-- Mailchimp Subscribe Form -->
            <!-- 
			<div class="border p-5 bg-lightblue">
				<div class="row justify-content-between">
					<div class="col-md-6 mb-2 mb-md-0">
						<h5 class="font-weight-bold">Join Newsletter</h5>
						 Get the latest news right in your inbox. We never spam!
					</div>
					<div class="col-md-6">
						<div class="row">
                            <form action="https://wowthemes.us11.list-manage.com/subscribe/post?u=8aeb20a530e124561927d3bd8&amp;id=8c3d2d214b" method="post" name="mc-embedded-subscribe-form" class="wj-contact-form validate w-100" target="_blank" novalidate>
                            <div class="mc-field-group">

								<input type="email" placeholder="Enter e-mail address" name="EMAIL" class="required email form-control w-100" id="mce-EMAIL" autocomplete="on" required>


								<button type="submit" value="Subscribe" name="subscribe" class="heart btn btn-success btn-block w-100 mt-2">Subscribe</button>

                            </div>
                            </form>
						</div>
					</div>
				</div>
			</div> -->
            


             <!-- Author Box -->
                
				<div class="row mt-5">
					<div class="col-md-2 align-self-center">
                         
                        <img class="rounded-circle" src="/assets/images/avatar1.png" alt="Magicblock" width="90"/>
                        
					</div>
					<div class="col-md-10">
                        <h5 class="font-weight-bold">Magicblock <span><a target="_blank" href="https://twitter.com/magicblock" class="btn btn-outline-success btn-sm btn-round ml-2">Follow</a></span></h5>
						
					</div>
				</div>
                

            <!-- Comments -->
            
                <!--  Don't edit anything here. Set your disqus id in _config.yml -->

<!-- <div id="comments" class="mt-5">
    <div id="disqus_thread">
    </div>
    <script type="text/javascript">
        var disqus_shortname = ''; 
        var disqus_developer = 0;
        (function() {
            var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
            dsq.src = window.location.protocol + '//' + disqus_shortname + '.disqus.com/embed.js';
            (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
        })();
    </script>
    <noscript>
    Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a>
    </noscript>
</div> -->
            

		</div>


	</div>
</div>


<!-- Aletbar Prev/Next -->
<div class="alertbar">
    <div class="container">
        <div class="row prevnextlinks small font-weight-bold">
          
            <div class="col-md-6 rightborder pl-0">
                <a class="text-dark" href="/supersize-hackathon/"> <img height="30px" class="mr-1" src="/assets/images/supersize-hackathon.png">  From Hackathon Winner to Fully On-Chain Pioneer – How Lewis Built Supersize</a>
            </div>
          
          
            <div class="col-md-6 text-right pr-0">
                <a class="text-dark" href="/dtelecom/"> dTelecom x MagicBlock: Powering the Future of Real-Time Decentralized Communication  <img height="30px" class="ml-1" src="/assets/images/dtelecom.png"> </a>
            </div>
          
        </div>
    </div>
</div>

    </main>


    <!-- Scripts: popper, bootstrap, theme, lunr -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/1.14.6/umd/popper.min.js" integrity="sha384-wHAiFfRlMFy6i5SRaxvfOCifBUQy1xHdJ/yoi7FRNXMRBu5WHdZYu1hA6ZOblgut" crossorigin="anonymous"></script>

    <script src="https://stackpath.bootstrapcdn.com/bootstrap/4.2.1/js/bootstrap.min.js" integrity="sha384-B0UglyR+jN6CkvvICOB2joaf5I4l3gm9GU6Hc1og6Ls7i6U/mkkaduKaBhlAXv9k" crossorigin="anonymous"></script>

    <script src="/assets/js/theme.js"></script>


    <!-- Footer -->
    <footer class="bg-white border-top p-3 text-muted small">
        <div class="container">
        <div class="row align-items-center justify-content-between">
            <div>
                <span class="navbar-brand mr-2 mb-0"><strong>Magicblock</strong></span>
                <span>Copyright © <script>document.write(new Date().getFullYear())</script>.</span>
            </div>
        </div>
        </div>
    </footer>

    <!-- All this area goes before </body> closing tag --> 


</body>

</html>
